//$file${.::tunnel.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: game.qm
// File:  ${.::tunnel.c}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open source software: you can redistribute it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// NOTE:
// Alternatively, this generated code may be distributed under the terms
// of Quantum Leaps commercial licenses, which expressly supersede the GNU
// General Public License and are specifically designed for licensees
// interested in retaining the proprietary status of their code.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::tunnel.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpc.h"
#include "bsp.h"
#include "game.h"

Q_DEFINE_THIS_FILE

// local objects -----------------------------------------------------------
//$declare${AOs::Tunnel} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::Tunnel} .............................................................
typedef struct Tunnel {
// protected:
    QActive super;

// private:
    QTimeEvt blinkTimeEvt;
    QTimeEvt screenTimeEvt;
    QHsm * mines[GAME_MINES_MAX];
    QHsm * mine1_pool[GAME_MINES_MAX];
    QHsm * mine2_pool[GAME_MINES_MAX];
    uint8_t blink_ctr;
    uint8_t last_mine_x;
    uint8_t last_mine_y;
    uint8_t wall_thickness_top;
    uint8_t wall_thickness_bottom;
    uint8_t wall_gap;

// public:
} Tunnel;
extern Tunnel Tunnel_inst;

// private:
static void Tunnel_advance(Tunnel * const me);
static void Tunnel_plantMine(Tunnel * const me);
static void Tunnel_dispatchToAllMines(Tunnel * const me,
    QEvt const * e);

// public:
static void Tunnel_ctor(Tunnel * const me);

// protected:
static QState Tunnel_initial(Tunnel * const me, void const * const par);
static QState Tunnel_active(Tunnel * const me, QEvt const * const e);
static QState Tunnel_show_logo(Tunnel * const me, QEvt const * const e);
static QState Tunnel_demo(Tunnel * const me, QEvt const * const e);
static QState Tunnel_playing(Tunnel * const me, QEvt const * const e);
static QState Tunnel_game_over(Tunnel * const me, QEvt const * const e);
static QState Tunnel_screen_saver(Tunnel * const me, QEvt const * const e);
static QState Tunnel_screen_saver_hide(Tunnel * const me, QEvt const * const e);
static QState Tunnel_screen_saver_show(Tunnel * const me, QEvt const * const e);
static QState Tunnel_final(Tunnel * const me, QEvt const * const e);
//$enddecl${AOs::Tunnel} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Public-scope objects ----------------------------------------------------
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${Shared::AO_Tunnel} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${Shared::AO_Tunnel} .......................................................
QActive * const AO_Tunnel = &Tunnel_inst.super;
//$enddef${Shared::AO_Tunnel} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

// Active object definition ================================================
//$define${Shared::Tunnel_ctor_call} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${Shared::Tunnel_ctor_call} ................................................
void Tunnel_ctor_call(void) {
    Tunnel_ctor(&Tunnel_inst);
}
//$enddef${Shared::Tunnel_ctor_call} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AOs::Tunnel} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::Tunnel} .............................................................
Tunnel Tunnel_inst;

//${AOs::Tunnel::advance} ....................................................
static void Tunnel_advance(Tunnel * const me) {
    uint32_t rnd;

    rnd = (BSP_random() & 0xFFU);

    // reduce the top wall thickness 18.75% of the time
    if ((rnd < 48U) && (me->wall_thickness_top > 0U)) {
        --me->wall_thickness_top;
    }

    // reduce the bottom wall thickness 18.75% of the time
    if ((rnd > 208U) && (me->wall_thickness_bottom > 0U)) {
        --me->wall_thickness_bottom;
    }

    rnd = (BSP_random() & 0xFFU);

    // grow the bottom wall thickness 19.14% of the time
    if ((rnd < 49U)
        && ((GAME_TUNNEL_HEIGHT
             - me->wall_thickness_top
             - me->wall_thickness_bottom) > me->wall_gap))
    {
        ++me->wall_thickness_bottom;
    }

    // grow the top wall thickness 19.14% of the time
    if ((rnd > 207U)
        && ((GAME_TUNNEL_HEIGHT
             - me->wall_thickness_top
             - me->wall_thickness_bottom) > me->wall_gap))
    {
        ++me->wall_thickness_top;
    }

    // advance the Tunnel by 1 game step to the left
    // and copy the Tunnel layer to the main frame buffer
    BSP_advanceWalls(me->wall_thickness_top, me->wall_thickness_bottom);
}

//${AOs::Tunnel::plantMine} ..................................................
static void Tunnel_plantMine(Tunnel * const me) {
    uint32_t rnd = (BSP_random() & 0xFFU);

    if (me->last_mine_x > 0U) {
        --me->last_mine_x; // shift the last Mine 1 position to the left
    }
    // last mine far enough?
    if ((me->last_mine_x + GAME_MINES_DIST_MIN < GAME_TUNNEL_WIDTH)
        && (rnd < 8U)) // place the mines only 5% of the time
    {
        // look for disabled mines...
        uint8_t n;
        for (n = 0U; n < Q_DIM(me->mines); ++n) {
            if (me->mines[n] == (QHsm *)0) {
                break;
            }
        }
        if (n < Q_DIM(me->mines)) { // a disabled Mine found?
            rnd = (BSP_random() & 0xFFFFU);

            if ((rnd & 1U) == 0U) { // choose the type of the mine
                me->mines[n] = me->mine1_pool[n];
            }
            else {
                me->mines[n] = me->mine2_pool[n];
            }

            // new Mine is planted by the end of the tunnel
            me->last_mine_x = GAME_TUNNEL_WIDTH - 8U;

            // choose a random y-position for the Mine in the Tunnel
            rnd %= (GAME_TUNNEL_HEIGHT
                    - me->wall_thickness_top
                    - me->wall_thickness_bottom - 4U);
            me->last_mine_y = (uint8_t)(me->wall_thickness_top + 2U + rnd);

            // event to dispatch to the Mine
            ObjectPosEvt ope = {
                QEVT_INITIALIZER(MINE_PLANT_SIG),
                .x = me->last_mine_x,
                .y = me->last_mine_y
            };
            QASM_DISPATCH(me->mines[n], &ope.super, me->super.prio);
        }
    }
}

//${AOs::Tunnel::dispatchToAllMines} .........................................
static void Tunnel_dispatchToAllMines(Tunnel * const me,
    QEvt const * e)
{
    for (uint8_t n = 0U; n < GAME_MINES_MAX; ++n) {
        if (me->mines[n] != (QHsm *)0) { // is the mine used?
            QASM_DISPATCH(me->mines[n], e, me->super.prio);
        }
    }
}

//${AOs::Tunnel::ctor} .......................................................
static void Tunnel_ctor(Tunnel * const me) {
    uint8_t n;
    QActive_ctor(&me->super, Q_STATE_CAST(&Tunnel_initial));
    QTimeEvt_ctorX(&me->blinkTimeEvt,  &me->super, BLINK_TIMEOUT_SIG,  0U);
    QTimeEvt_ctorX(&me->screenTimeEvt, &me->super, SCREEN_TIMEOUT_SIG, 0U);
    for (n = 0; n < GAME_MINES_MAX; ++n) {
        me->mine1_pool[n] = Mine1_ctor_call(n); // instantiate Mine1
        me->mine2_pool[n] = Mine2_ctor_call(n); // instantiate Mine2
        me->mines[n] = (QHsm *)0; // mine 'n' is unused
    }
    me->last_mine_x = 0; // the last mine at the right edge of the tunnel
    me->last_mine_y = 0;
}

//${AOs::Tunnel::SM} .........................................................
static QState Tunnel_initial(Tunnel * const me, void const * const par) {
    //${AOs::Tunnel::SM::initial}
    uint8_t n;
    for (n = 0U; n < GAME_MINES_MAX; ++n) {
        QASM_INIT(me->mine1_pool[n], (void *)0, me->super.prio);
        QASM_INIT(me->mine2_pool[n], (void *)0, me->super.prio);
    }
    BSP_randomSeed(1234); // seed the pseudo-random generator

    QActive_subscribe(&me->super, TIME_TICK_SIG);
    QActive_subscribe(&me->super, PLAYER_TRIGGER_SIG);
    QActive_subscribe(&me->super, PLAYER_QUIT_SIG);

    // object dictionaries...
    QS_OBJ_DICTIONARY(&Tunnel_inst.blinkTimeEvt);
    QS_OBJ_DICTIONARY(&Tunnel_inst.screenTimeEvt);

    // local signals...
    QS_SIG_DICTIONARY(BLINK_TIMEOUT_SIG,  me);
    QS_SIG_DICTIONARY(SCREEN_TIMEOUT_SIG, me);
    QS_SIG_DICTIONARY(SHIP_IMG_SIG,       me);
    QS_SIG_DICTIONARY(MISSILE_IMG_SIG,    me);
    QS_SIG_DICTIONARY(MINE_IMG_SIG,       me);
    QS_SIG_DICTIONARY(MINE_DISABLED_SIG,  me);
    QS_SIG_DICTIONARY(EXPLOSION_SIG,      me);
    QS_SIG_DICTIONARY(SCORE_SIG,          me);

    (void)par;  // unused parameter

    QS_FUN_DICTIONARY(&Tunnel_active);
    QS_FUN_DICTIONARY(&Tunnel_show_logo);
    QS_FUN_DICTIONARY(&Tunnel_demo);
    QS_FUN_DICTIONARY(&Tunnel_playing);
    QS_FUN_DICTIONARY(&Tunnel_game_over);
    QS_FUN_DICTIONARY(&Tunnel_screen_saver);
    QS_FUN_DICTIONARY(&Tunnel_screen_saver_hide);
    QS_FUN_DICTIONARY(&Tunnel_screen_saver_show);
    QS_FUN_DICTIONARY(&Tunnel_final);

    return Q_TRAN(&Tunnel_show_logo);
}

//${AOs::Tunnel::SM::active} .................................................
static QState Tunnel_active(Tunnel * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Tunnel::SM::active::MINE_DISABLED}
        case MINE_DISABLED_SIG: {
            Q_ASSERT((Q_EVT_CAST(MineEvt)->id < GAME_MINES_MAX)
                     && (me->mines[Q_EVT_CAST(MineEvt)->id] != (QHsm *)0));
            me->mines[Q_EVT_CAST(MineEvt)->id] = (QHsm *)0;
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::PLAYER_QUIT}
        case PLAYER_QUIT_SIG: {
            status_ = Q_TRAN(&Tunnel_final);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${AOs::Tunnel::SM::active::show_logo} ......................................
static QState Tunnel_show_logo(Tunnel * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Tunnel::SM::active::show_logo}
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->blinkTimeEvt, BSP_TICKS_PER_SEC/2U,
                          BSP_TICKS_PER_SEC/2U);
            QTimeEvt_armX(&me->screenTimeEvt, BSP_TICKS_PER_SEC*5U, 0U);
            me->blink_ctr = 0U;
            BSP_paintString(24U, (GAME_TUNNEL_HEIGHT / 2U) - 8U, "Quantum LeAps");
            BSP_paintString(16U, (GAME_TUNNEL_HEIGHT / 2U) + 0U, "state-machine.com");

            BSP_paintString(1U, GAME_TUNNEL_HEIGHT - 18U, "Fire missile: BTN0");
            BSP_paintString(1U, GAME_TUNNEL_HEIGHT - 10U, "Fly ship up:  BTN1");

            BSP_updateScreen();
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::show_logo}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->blinkTimeEvt);
            QTimeEvt_disarm(&me->screenTimeEvt);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::show_logo::SCREEN_TIMEOUT}
        case SCREEN_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Tunnel_demo);
            break;
        }
        //${AOs::Tunnel::SM::active::show_logo::BLINK_TIMEOUT}
        case BLINK_TIMEOUT_SIG: {
            me->blink_ctr ^= 1U; // toggle the blink counter
            //${AOs::Tunnel::SM::active::show_logo::BLINK_TIMEOUT::[me->blink_ctr==0U]}
            if (me->blink_ctr == 0U) {
                BSP_paintString(24U + 8U*6U, (GAME_TUNNEL_HEIGHT / 2U) - 8U, "LeAps");
                BSP_updateScreen();
                status_ = Q_HANDLED();
            }
            //${AOs::Tunnel::SM::active::show_logo::BLINK_TIMEOUT::[else]}
            else {
                BSP_paintString(24U + 8U*6U, (GAME_TUNNEL_HEIGHT / 2U) - 8U, "LeaPs");
                BSP_updateScreen();
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Tunnel_active);
            break;
        }
    }
    return status_;
}

//${AOs::Tunnel::SM::active::demo} ...........................................
static QState Tunnel_demo(Tunnel * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Tunnel::SM::active::demo}
        case Q_ENTRY_SIG: {
            me->last_mine_x = 0U; // last mine at right edge of the tunnel
            me->last_mine_y = 0U;
            // set the tunnel properties...
            me->wall_thickness_top = 0U;
            me->wall_thickness_bottom = 0U;
            me->wall_gap = GAME_WALLS_GAP_Y;

            // clear the tunnel walls
            BSP_clearWalls();

            QTimeEvt_armX(&me->blinkTimeEvt,  BSP_TICKS_PER_SEC/2U,
                          BSP_TICKS_PER_SEC/2U); // every 1/2 sec
            QTimeEvt_armX(&me->screenTimeEvt, BSP_TICKS_PER_SEC*20U, 0U);

            me->blink_ctr = 0U; // init the blink counter
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::demo}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->blinkTimeEvt);
            QTimeEvt_disarm(&me->screenTimeEvt);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::demo::BLINK_TIMEOUT}
        case BLINK_TIMEOUT_SIG: {
            me->blink_ctr ^= 1U; // toggle the blink cunter
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::demo::SCREEN_TIMEOUT}
        case SCREEN_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Tunnel_screen_saver);
            break;
        }
        //${AOs::Tunnel::SM::active::demo::TIME_TICK}
        case TIME_TICK_SIG: {
            Tunnel_advance(me);
            if (me->blink_ctr != 0U) {
                // add the text bitmap into the frame buffer
                BSP_paintString((GAME_TUNNEL_WIDTH - 10U*6U)/2U,
                                (GAME_TUNNEL_HEIGHT - 4U)/2U,
                                "Press BTN0");
            }
            BSP_updateScreen();
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::demo::PLAYER_TRIGGER}
        case PLAYER_TRIGGER_SIG: {
            status_ = Q_TRAN(&Tunnel_playing);
            break;
        }
        default: {
            status_ = Q_SUPER(&Tunnel_active);
            break;
        }
    }
    return status_;
}

//${AOs::Tunnel::SM::active::playing} ........................................
static QState Tunnel_playing(Tunnel * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Tunnel::SM::active::playing}
        case Q_ENTRY_SIG: {
            static QEvt const takeoff = QEVT_INITIALIZER(TAKE_OFF_SIG);
            me->wall_gap = GAME_WALLS_GAP_Y;
            QACTIVE_POST(AO_Ship, &takeoff, me); // post the TAKEOFF sig
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::playing}
        case Q_EXIT_SIG: {
            static QEvt const recycle = QEVT_INITIALIZER(MINE_RECYCLE_SIG);
            Tunnel_dispatchToAllMines(me, &recycle); // recycle all Mines
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::playing::TIME_TICK}
        case TIME_TICK_SIG: {
            // render this frame on the display
            BSP_updateScreen();
            Tunnel_advance(me);
            Tunnel_plantMine(me);
            Tunnel_dispatchToAllMines(me, e);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::playing::SHIP_IMG}
        case SHIP_IMG_SIG: {
            uint8_t x   = Q_EVT_CAST(ObjectImageEvt)->x;
            int8_t  y   = Q_EVT_CAST(ObjectImageEvt)->y;
            uint8_t bmp = Q_EVT_CAST(ObjectImageEvt)->bmp;

            // did the Ship/Missile hit the tunnel wall?
            if (BSP_isWallHit(bmp, x, y)) {
                static QEvt const hit = QEVT_INITIALIZER(HIT_WALL_SIG);
                QACTIVE_POST(AO_Ship, &hit, me);
            }
            BSP_paintBitmap(x, y, bmp);
            Tunnel_dispatchToAllMines(me, e); // let Mines check for hits
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::playing::MISSILE_IMG}
        case MISSILE_IMG_SIG: {
            uint8_t x   = Q_EVT_CAST(ObjectImageEvt)->x;
            int8_t  y   = Q_EVT_CAST(ObjectImageEvt)->y;
            uint8_t bmp = Q_EVT_CAST(ObjectImageEvt)->bmp;

            // did the Ship/Missile hit the tunnel wall?
            if (BSP_isWallHit(bmp, x, y)) {
                static QEvt const hit = QEVT_INITIALIZER(HIT_WALL_SIG);
                QACTIVE_POST(AO_Missile, &hit, me);
            }
            BSP_paintBitmap(x, y, bmp);
            Tunnel_dispatchToAllMines(me, e); // let Mines check for hits
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::playing::MINE_IMG}
        case MINE_IMG_SIG: {
            BSP_paintBitmap(Q_EVT_CAST(ObjectImageEvt)->x,
                            Q_EVT_CAST(ObjectImageEvt)->y,
                            Q_EVT_CAST(ObjectImageEvt)->bmp);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::playing::EXPLOSION}
        case EXPLOSION_SIG: {
            BSP_paintBitmap(Q_EVT_CAST(ObjectImageEvt)->x,
                            Q_EVT_CAST(ObjectImageEvt)->y,
                            Q_EVT_CAST(ObjectImageEvt)->bmp);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::playing::SCORE}
        case SCORE_SIG: {
            BSP_updateScore(Q_EVT_CAST(ScoreEvt)->score);
            // increase difficulty of the game:
            // the tunnel gets narrower as the score goes up
            me->wall_gap = (uint8_t)(GAME_WALLS_GAP_Y
                              - Q_EVT_CAST(ScoreEvt)->score/100U);
            if (me->wall_gap < GAME_WALLS_MIN_GAP_Y) {
                me->wall_gap = GAME_WALLS_MIN_GAP_Y;
            }
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::playing::GAME_OVER}
        case GAME_OVER_SIG: {
            BSP_clearWalls();
            BSP_updateScore(Q_EVT_CAST(ScoreEvt)->score);
            BSP_updateScreen();
            status_ = Q_TRAN(&Tunnel_game_over);
            break;
        }
        default: {
            status_ = Q_SUPER(&Tunnel_active);
            break;
        }
    }
    return status_;
}

//${AOs::Tunnel::SM::active::game_over} ......................................
static QState Tunnel_game_over(Tunnel * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Tunnel::SM::active::game_over}
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->blinkTimeEvt, BSP_TICKS_PER_SEC/2U,
                          BSP_TICKS_PER_SEC/2U); // every 1/2 sec
            QTimeEvt_armX(&me->screenTimeEvt, BSP_TICKS_PER_SEC*5U, 0U);
            me->blink_ctr = 0U;
            BSP_paintString((GAME_TUNNEL_WIDTH - 6U * 9U) / 2U,
                            (GAME_TUNNEL_HEIGHT / 2U) - 4U,
                            "Game Over");
            BSP_updateScreen();
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::game_over}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->blinkTimeEvt);
            QTimeEvt_disarm(&me->screenTimeEvt);
            BSP_updateScore(0); // update the score on the display
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::game_over::BLINK_TIMEOUT}
        case BLINK_TIMEOUT_SIG: {
            me->blink_ctr ^= 1U; // toggle the blink counter
            BSP_paintString((GAME_TUNNEL_WIDTH - 6U*9U) / 2U,
                            (GAME_TUNNEL_HEIGHT / 2U) - 4U,
                            ((me->blink_ctr == 0U)
                            ? "Game Over"
                            : "         "));
            BSP_updateScreen();
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::game_over::SCREEN_TIMEOUT}
        case SCREEN_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Tunnel_demo);
            break;
        }
        default: {
            status_ = Q_SUPER(&Tunnel_active);
            break;
        }
    }
    return status_;
}

//${AOs::Tunnel::SM::active::screen_saver} ...................................
static QState Tunnel_screen_saver(Tunnel * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Tunnel::SM::active::screen_saver::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Tunnel_screen_saver_hide);
            break;
        }
        //${AOs::Tunnel::SM::active::screen_saver::PLAYER_TRIGGER}
        case PLAYER_TRIGGER_SIG: {
            status_ = Q_TRAN(&Tunnel_demo);
            break;
        }
        default: {
            status_ = Q_SUPER(&Tunnel_active);
            break;
        }
    }
    return status_;
}

//${AOs::Tunnel::SM::active::screen_saver::screen_saver_hide} ................
static QState Tunnel_screen_saver_hide(Tunnel * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Tunnel::SM::active::screen_saver::screen_saver_hide}
        case Q_ENTRY_SIG: {
            BSP_displayOff(); // power down the display
            QTimeEvt_armX(&me->screenTimeEvt, BSP_TICKS_PER_SEC*3U, 0U);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::screen_saver::screen_saver_hide}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->screenTimeEvt);
            BSP_displayOn(); // power up the display
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::screen_saver::screen_saver_hid~::SCREEN_TIMEOUT}
        case SCREEN_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Tunnel_screen_saver_show);
            break;
        }
        default: {
            status_ = Q_SUPER(&Tunnel_screen_saver);
            break;
        }
    }
    return status_;
}

//${AOs::Tunnel::SM::active::screen_saver::screen_saver_show} ................
static QState Tunnel_screen_saver_show(Tunnel * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Tunnel::SM::active::screen_saver::screen_saver_show}
        case Q_ENTRY_SIG: {
            uint32_t rnd = BSP_random();
            // clear the screen frame buffer
            BSP_clearFB();
            BSP_paintString((uint8_t)(rnd % (GAME_TUNNEL_WIDTH - 10U*6U)),
                            (uint8_t) (rnd % (GAME_TUNNEL_HEIGHT - 8U)),
                            "Press BTN0");
            BSP_updateScreen();
            QTimeEvt_armX(&me->screenTimeEvt, BSP_TICKS_PER_SEC/2U, 0U);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::screen_saver::screen_saver_show}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->screenTimeEvt);
            BSP_clearFB();
            BSP_updateScreen();
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Tunnel::SM::active::screen_saver::screen_saver_sho~::SCREEN_TIMEOUT}
        case SCREEN_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Tunnel_screen_saver_hide);
            break;
        }
        default: {
            status_ = Q_SUPER(&Tunnel_screen_saver);
            break;
        }
    }
    return status_;
}

//${AOs::Tunnel::SM::final} ..................................................
static QState Tunnel_final(Tunnel * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Tunnel::SM::final}
        case Q_ENTRY_SIG: {
            // clear the screen
            BSP_clearFB();
            BSP_updateScreen();
            QF_stop(); // stop QF and cleanup
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
//$enddef${AOs::Tunnel} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
