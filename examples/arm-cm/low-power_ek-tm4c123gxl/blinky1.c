/*.$file${.::blinky1.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: low-power.qm
* File:  ${.::blinky1.c}
*
* This code has been generated by QM 5.1.0 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::blinky1.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include "low_power.h"
#include "bsp.h"

//Q_DEFINE_THIS_FILE

/*.$declare${AOs::Blinky1} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::Blinky1} .........................................................*/
typedef struct Blinky1 {
/* protected: */
    QActive super;

/* public: */

/* private: */
    QTimeEvt timeEvt1;
    uint8_t count;
} Blinky1;
extern Blinky1 Blinky1_instance;

/* protected: */
static QState Blinky1_initial(Blinky1 * const me, void const * const par);
static QState Blinky1_inactive(Blinky1 * const me, QEvt const * const e);
static QState Blinky1_active(Blinky1 * const me, QEvt const * const e);
static QState Blinky1_off(Blinky1 * const me, QEvt const * const e);
static QState Blinky1_on(Blinky1 * const me, QEvt const * const e);
/*.$enddecl${AOs::Blinky1} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.8.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::AO_Blinky1} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::AO_Blinky1} ......................................................*/
QActive * const AO_Blinky1 = &Blinky1_instance.super;
/*.$enddef${AOs::AO_Blinky1} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*.$define${AOs::Blinky1} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::Blinky1} .........................................................*/
Blinky1 Blinky1_instance;
/*.${AOs::Blinky1::SM} .....................................................*/
static QState Blinky1_initial(Blinky1 * const me, void const * const par) {
    /*.${AOs::Blinky1::SM::initial} */
    (void)par; /* unused parameter */
    QActive_subscribe(&me->super, BTN_PRESSED_SIG);

    QS_FUN_DICTIONARY(&Blinky1_inactive);
    QS_FUN_DICTIONARY(&Blinky1_active);
    QS_FUN_DICTIONARY(&Blinky1_off);
    QS_FUN_DICTIONARY(&Blinky1_on);

    return Q_TRAN(&Blinky1_inactive);
}
/*.${AOs::Blinky1::SM::inactive} ...........................................*/
static QState Blinky1_inactive(Blinky1 * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Blinky1::SM::inactive::BTN_PRESSED} */
        case BTN_PRESSED_SIG: {
            status_ = Q_TRAN(&Blinky1_active);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::Blinky1::SM::active} .............................................*/
static QState Blinky1_active(Blinky1 * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Blinky1::SM::active} */
        case Q_ENTRY_SIG: {
            BSP_tickRate1_on();
            me->count = 13U;
            QTimeEvt_armX(&me->timeEvt1, 2U, 2U);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Blinky1::SM::active} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->timeEvt1);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Blinky1::SM::active::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Blinky1_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${AOs::Blinky1::SM::active::off} ........................................*/
static QState Blinky1_off(Blinky1 * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Blinky1::SM::active::off::TIMEOUT1} */
        case TIMEOUT1_SIG: {
            status_ = Q_TRAN(&Blinky1_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&Blinky1_active);
            break;
        }
    }
    return status_;
}
/*.${AOs::Blinky1::SM::active::on} .........................................*/
static QState Blinky1_on(Blinky1 * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Blinky1::SM::active::on} */
        case Q_ENTRY_SIG: {
            BSP_led1_on();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Blinky1::SM::active::on} */
        case Q_EXIT_SIG: {
            BSP_led1_off();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Blinky1::SM::active::on::TIMEOUT1} */
        case TIMEOUT1_SIG: {
            --me->count;
            /*.${AOs::Blinky1::SM::active::on::TIMEOUT1::[me->count>0]} */
            if (me->count > 0) {
                status_ = Q_TRAN(&Blinky1_off);
            }
            /*.${AOs::Blinky1::SM::active::on::TIMEOUT1::[else]} */
            else {
                status_ = Q_TRAN(&Blinky1_inactive);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Blinky1_active);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::Blinky1} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*.$define${AOs::Blinky1_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::Blinky1_ctor} ....................................................*/
void Blinky1_ctor(void) {
    Blinky1 *me = &Blinky1_instance;
    QActive_ctor(&me->super, Q_STATE_CAST(&Blinky1_initial));
    QTimeEvt_ctorX(&me->timeEvt1, &me->super, TIMEOUT1_SIG, 1U);
}
/*.$enddef${AOs::Blinky1_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
